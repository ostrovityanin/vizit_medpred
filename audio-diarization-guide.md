# Руководство по использованию микросервиса аудио-диаризации

## Описание

Микросервис аудио-диаризации предназначен для определения различных говорящих в аудиозаписях и разделения речи на сегменты по говорящим. Он позволяет идентифицировать, кто и когда говорит в аудиозаписи, что особенно полезно для транскрипции диалогов, интервью и групповых обсуждений.

## Установка и запуск

### Требования

- Python 3.10 или выше
- NodeJS 18 или выше
- FFmpeg для обработки аудио

### Запуск микросервиса

Для запуска микросервиса используйте скрипт:

```bash
node start-diarization-service.js
```

Для остановки сервиса используйте:

```bash
node stop-diarization-service.js
```

## API микросервиса

Микросервис предоставляет REST API для диаризации аудиофайлов.

### Проверка работоспособности (Health Check)

```
GET http://localhost:5001/health
```

Ответ:
```json
{
  "status": "ok",
  "service": "audio-diarization",
  "version": "1.0.0"
}
```

### Диаризация аудио

```
POST http://localhost:5001/diarize
```

Параметры (multipart/form-data):
- `file` - аудиофайл (WAV, MP3, OGG и др.)
- `min_speakers` - минимальное ожидаемое количество говорящих (по умолчанию 1)
- `max_speakers` - максимальное ожидаемое количество говорящих (по умолчанию 10)
- `return_segments` - возвращать ли файлы сегментов (по умолчанию false)

Пример ответа:
```json
{
  "speakers": [1, 2],
  "segments": [
    {
      "start": 0.5,
      "end": 3.2,
      "speaker": 1
    },
    {
      "start": 4.1,
      "end": 7.3,
      "speaker": 2
    },
    {
      "start": 8.0,
      "end": 10.5,
      "speaker": 1
    }
  ],
  "processing_time": 1.23
}
```

## Интеграция с API транскрипции

Микросервис диаризации интегрирован с основным сервером через API транскрипции. Вы можете использовать эндпоинт `/api/diarize` для получения диаризации и опциональной транскрипции каждого сегмента.

### Использование API диаризации

```
POST http://localhost:3000/api/diarize
```

Параметры (multipart/form-data):
- `file` - аудиофайл
- `min_speakers` - минимальное количество говорящих
- `max_speakers` - максимальное количество говорящих
- `transcribe` - транскрибировать ли сегменты (true/false)
- `language` - язык транскрипции (ru, en и т.д.)

Пример ответа с транскрипцией:
```json
{
  "speakers": [1, 2],
  "segments": [
    {
      "start": 0.5,
      "end": 3.2,
      "speaker": 1,
      "transcription": "Привет, как дела?"
    },
    {
      "start": 4.1,
      "end": 7.3,
      "speaker": 2,
      "transcription": "Все хорошо, спасибо!"
    }
  ],
  "full_transcript": "Speaker 1: Привет, как дела?\n\nSpeaker 2: Все хорошо, спасибо!",
  "processing_time": 2.45
}
```

## Тестирование

Для тестирования микросервиса диаризации предоставлены следующие инструменты:

1. Генерация тестового аудиофайла:
   ```
   node generate-test-audio.js
   ```
   Создает тестовый аудиофайл с разными "говорящими" (разные частоты тона).

2. Тестирование микросервиса напрямую:
   ```
   node test-diarization-service.js
   ```
   Проверяет работу микросервиса, отправляя запрос напрямую.

3. Тестирование через API:
   ```
   node test-api-diarization.js
   ```
   Тестирует интеграцию с основным API сервера.

## Архитектура и принцип работы

Микросервис использует алгоритм кластеризации спектральных признаков аудио для определения различных говорящих. Основные шаги работы:

1. Аудиофайл конвертируется в монофонический WAV с частотой 16 кГц.
2. Извлекаются спектральные признаки (MFCC) для каждого фрейма.
3. Определяются участки с голосовой активностью.
4. Выполняется кластеризация признаков для выделения говорящих.
5. Создаются сегменты с временными метками для каждого говорящего.
6. При необходимости каждый сегмент транскрибируется отдельно.

## Ограничения

1. Точность определения говорящих зависит от качества аудио и акустических условий записи.
2. Для записей с большим количеством говорящих (> 5) может потребоваться ручная настройка параметров.
3. Перекрывающиеся голоса могут быть определены некорректно.

## Возможные проблемы и их решение

1. **Микросервис не запускается**
   - Проверьте наличие всех зависимостей Python
   - Убедитесь, что порт 5001 не занят другим приложением

2. **Ошибка при обработке аудиофайла**
   - Проверьте формат и целостность аудиофайла
   - Конвертируйте аудио в поддерживаемый формат (MP3, WAV) с помощью FFmpeg

3. **Неточное определение говорящих**
   - Попробуйте изменить параметры min_speakers и max_speakers
   - Улучшите качество аудиозаписи (снизьте шум, удалите фоновую музыку)