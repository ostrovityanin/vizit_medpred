<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Сервис мониторинга - Telegram Mini App Audio Recorder</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      padding-top: 20px;
      background-color: #f8f9fa;
    }
    .service-card {
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s;
    }
    .service-card:hover {
      transform: translateY(-5px);
    }
    .service-card.active {
      border-left: 5px solid #28a745;
    }
    .service-card.inactive {
      border-left: 5px solid #dc3545;
    }
    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 5px;
    }
    .status-indicator.active {
      background-color: #28a745;
    }
    .status-indicator.inactive {
      background-color: #dc3545;
    }
    .dashboard-header {
      background: linear-gradient(135deg, #0d6efd, #0dcaf0);
      color: white;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 30px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .chart-container {
      background: white;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      height: 300px;
    }
    .metrics-card {
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .telegram-log {
      max-height: 500px;
      overflow-y: auto;
    }
    .recovery-log {
      max-height: 300px;
      overflow-y: auto;
    }
    #serviceStatusTable th, #serviceStatusTable td {
      vertical-align: middle;
    }
    .response-time {
      font-size: 0.9rem;
      color: #6c757d;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="dashboard-header text-center">
      <h1>Telegram Mini App Audio Recorder</h1>
      <h3>Панель мониторинга микросервисов</h3>
      <p class="mb-0">Отслеживание состояния и производительности сервисов в реальном времени</p>
    </div>

    <div class="row mb-4">
      <div class="col-md-6">
        <div class="metrics-card bg-white p-4">
          <h4 class="mb-3">Общая статистика</h4>
          <div class="row">
            <div class="col-6">
              <div class="card bg-light mb-3">
                <div class="card-body text-center">
                  <h5 class="card-title">Сервисы активны</h5>
                  <h2 id="activeServicesCount" class="text-success">0/0</h2>
                </div>
              </div>
            </div>
            <div class="col-6">
              <div class="card bg-light mb-3">
                <div class="card-body text-center">
                  <h5 class="card-title">Статус системы</h5>
                  <h2 id="systemStatus" class="text-primary">-</h2>
                </div>
              </div>
            </div>
          </div>
          <div class="row">
            <div class="col-6">
              <div class="card bg-light mb-0">
                <div class="card-body text-center">
                  <h5 class="card-title">Время работы</h5>
                  <h2 id="uptimeDisplay" class="text-primary">-</h2>
                </div>
              </div>
            </div>
            <div class="col-6">
              <div class="card bg-light mb-0">
                <div class="card-body text-center">
                  <h5 class="card-title">Использование ОЗУ</h5>
                  <h2 id="memoryUsage" class="text-primary">-</h2>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="col-md-6">
        <div class="chart-container">
          <h4 class="mb-3">Время отклика сервисов (мс)</h4>
          <canvas id="responseTimeChart"></canvas>
        </div>
      </div>
    </div>

    <div class="row mb-4">
      <div class="col-12">
        <div class="card">
          <div class="card-header bg-primary text-white">
            <h4 class="mb-0">Статус микросервисов</h4>
          </div>
          <div class="card-body">
            <div class="table-responsive">
              <table id="serviceStatusTable" class="table table-striped table-hover">
                <thead>
                  <tr>
                    <th>Сервис</th>
                    <th>Статус</th>
                    <th>Время отклика</th>
                    <th>URL</th>
                    <th>Последняя проверка</th>
                  </tr>
                </thead>
                <tbody id="serviceStatusBody">
                  <!-- Данные будут добавлены через JavaScript -->
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="row mb-4">
      <div class="col-md-6">
        <div class="card">
          <div class="card-header bg-primary text-white">
            <h4 class="mb-0">Последние уведомления Telegram</h4>
          </div>
          <div class="card-body telegram-log">
            <div id="telegramMessages" class="list-group">
              <!-- Данные будут добавлены через JavaScript -->
            </div>
          </div>
        </div>
      </div>
      <div class="col-md-6">
        <div class="card">
          <div class="card-header bg-primary text-white">
            <h4 class="mb-0">Восстановление после сбоев</h4>
          </div>
          <div class="card-body recovery-log">
            <div id="recoveryLog" class="list-group">
              <!-- Данные будут добавлены через JavaScript -->
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="row mb-4">
      <div class="col-12">
        <div class="card">
          <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
            <h4 class="mb-0">Управление</h4>
            <button id="sendReportBtn" class="btn btn-sm btn-light">Отправить отчет в Telegram</button>
          </div>
          <div class="card-body">
            <div class="row">
              <div class="col-md-4">
                <div class="mb-3">
                  <label for="healthCheckInterval" class="form-label">Интервал проверки (мс)</label>
                  <input type="number" class="form-control" id="healthCheckInterval" value="60000">
                </div>
              </div>
              <div class="col-md-4">
                <div class="mb-3">
                  <label for="alertThreshold" class="form-label">Порог оповещения (мс)</label>
                  <input type="number" class="form-control" id="alertThreshold" value="2000">
                </div>
              </div>
              <div class="col-md-4">
                <div class="mb-3">
                  <label for="refreshRate" class="form-label">Частота обновления UI (мс)</label>
                  <input type="number" class="form-control" id="refreshRate" value="5000">
                </div>
              </div>
            </div>
            <div class="row mt-3">
              <div class="col-12">
                <button id="saveSettingsBtn" class="btn btn-primary">Сохранить настройки</button>
                <button id="refreshDataBtn" class="btn btn-outline-primary ms-2">Обновить данные</button>
                <button id="clearRecoveryLogBtn" class="btn btn-outline-secondary ms-2">Очистить лог восстановлений</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Определение сервисов для мониторинга
    const services = [
      { id: 'data-storage', name: 'Сервис хранения данных', url: 'http://localhost:3002/health' },
      { id: 'audio-processor', name: 'Сервис обработки аудио', url: 'http://localhost:3003/health' },
      { id: 'api-core', name: 'API Core сервис', url: 'http://localhost:3001/health' },
      { id: 'documentation', name: 'Сервис документации', url: 'http://localhost:3004/health' },
      { id: 'telegram-app', name: 'Telegram Mini App', url: 'http://localhost:3000/health' },
      { id: 'admin-panel', name: 'Админ-панель', url: 'http://localhost:3005/health' }
    ];

    // Глобальные переменные
    let responseTimeChart;
    let servicesStatus = {};
    let telegramMessages = [];
    let recoveryEvents = [];

    // Инициализация страницы
    document.addEventListener('DOMContentLoaded', () => {
      initializeResponseTimeChart();
      populateServiceTable();
      fetchInitialData();
      setupEventListeners();
      
      // Регулярное обновление данных
      setInterval(fetchStatusData, 5000); // Обновление каждые 5 секунд
    });

    // Инициализация графика времени отклика
    function initializeResponseTimeChart() {
      const ctx = document.getElementById('responseTimeChart').getContext('2d');
      responseTimeChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [], // Будет заполнено данными о времени
          datasets: services.map((service, index) => ({
            label: service.name,
            data: [],
            borderColor: getServiceColor(index),
            backgroundColor: 'transparent',
            borderWidth: 2,
            tension: 0.3,
            pointRadius: 3
          }))
        },
        options: {
          maintainAspectRatio: false,
          scales: {
            x: {
              grid: {
                display: false
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Время отклика (мс)'
              }
            }
          },
          plugins: {
            legend: {
              position: 'bottom'
            }
          }
        }
      });
    }

    // Цвета для сервисов на графике
    function getServiceColor(index) {
      const colors = [
        '#0d6efd', '#dc3545', '#28a745', '#fd7e14', '#6f42c1', '#20c997'
      ];
      return colors[index % colors.length];
    }

    // Заполнение таблицы сервисов
    function populateServiceTable() {
      const table = document.getElementById('serviceStatusBody');
      table.innerHTML = '';
      
      services.forEach(service => {
        const row = document.createElement('tr');
        row.id = `service-row-${service.id}`;
        row.innerHTML = `
          <td>${service.name}</td>
          <td><span class="status-indicator inactive"></span><span id="status-${service.id}">Проверка...</span></td>
          <td id="response-time-${service.id}">-</td>
          <td><small>${service.url}</small></td>
          <td id="last-check-${service.id}">-</td>
        `;
        table.appendChild(row);
      });
    }

    // Получение начальных данных
    function fetchInitialData() {
      fetchStatusData();
      fetchTelegramMessages();
      fetchRecoveryLog();
    }

    // Получение данных о статусе сервисов
    function fetchStatusData() {
      fetch('/api/status')
        .then(response => response.json())
        .then(data => {
          updateServicesStatus(data);
          updateSystemMetrics(data.system);
          updateResponseTimeChart(data.timestamp, data.services);
        })
        .catch(error => {
          console.error('Ошибка при получении данных о статусе:', error);
        });
    }

    // Получение истории сообщений Telegram
    function fetchTelegramMessages() {
      fetch('/api/telegram/messages')
        .then(response => response.json())
        .then(data => {
          telegramMessages = data;
          updateTelegramMessages();
        })
        .catch(error => {
          console.error('Ошибка при получении сообщений Telegram:', error);
        });
    }

    // Получение лога восстановлений
    function fetchRecoveryLog() {
      fetch('/api/recovery-log')
        .then(response => response.json())
        .then(data => {
          recoveryEvents = data;
          updateRecoveryLog();
        })
        .catch(error => {
          console.error('Ошибка при получении лога восстановлений:', error);
        });
    }

    // Обновление таблицы статуса сервисов
    function updateServicesStatus(data) {
      servicesStatus = data.services;
      
      // Подсчет активных сервисов
      const totalServices = services.length;
      const activeServices = Object.values(servicesStatus).filter(s => s.active).length;
      document.getElementById('activeServicesCount').textContent = `${activeServices}/${totalServices}`;
      
      // Определение статуса системы
      const systemStatus = activeServices === totalServices ? 'Исправна' : 'Проблема';
      document.getElementById('systemStatus').textContent = systemStatus;
      document.getElementById('systemStatus').className = activeServices === totalServices ? 'text-success' : 'text-danger';
      
      // Обновление строк таблицы
      services.forEach(service => {
        const serviceId = service.id;
        const statusElement = document.getElementById(`status-${serviceId}`);
        const indicatorElement = statusElement.previousElementSibling;
        const responseTimeElement = document.getElementById(`response-time-${serviceId}`);
        const lastCheckElement = document.getElementById(`last-check-${serviceId}`);
        const rowElement = document.getElementById(`service-row-${serviceId}`);
        
        if (servicesStatus[serviceId]) {
          const active = servicesStatus[serviceId].active;
          const responseTime = servicesStatus[serviceId].responseTime;
          const lastCheck = new Date(servicesStatus[serviceId].lastCheck).toLocaleTimeString();
          
          statusElement.textContent = active ? 'Активен' : 'Недоступен';
          indicatorElement.className = `status-indicator ${active ? 'active' : 'inactive'}`;
          responseTimeElement.textContent = responseTime ? `${responseTime} мс` : '-';
          lastCheckElement.textContent = lastCheck;
          
          rowElement.className = active ? '' : 'table-danger';
        }
      });
    }

    // Обновление метрик системы
    function updateSystemMetrics(systemData) {
      if (systemData) {
        document.getElementById('uptimeDisplay').textContent = formatUptime(systemData.uptime);
        document.getElementById('memoryUsage').textContent = formatMemory(systemData.memoryUsed, systemData.memoryTotal);
      }
    }

    // Форматирование времени работы
    function formatUptime(seconds) {
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      
      if (days > 0) {
        return `${days}д ${hours}ч ${minutes}м`;
      } else if (hours > 0) {
        return `${hours}ч ${minutes}м`;
      } else {
        return `${minutes}м ${seconds % 60}с`;
      }
    }

    // Форматирование использования памяти
    function formatMemory(used, total) {
      const usedMB = Math.round(used / 1024 / 1024);
      const totalMB = Math.round(total / 1024 / 1024);
      return `${usedMB}MB / ${totalMB}MB`;
    }

    // Обновление графика времени отклика
    function updateResponseTimeChart(timestamp, servicesData) {
      const timeLabel = new Date(timestamp).toLocaleTimeString();
      
      // Ограничение количества точек на графике
      if (responseTimeChart.data.labels.length > 20) {
        responseTimeChart.data.labels.shift();
        responseTimeChart.data.datasets.forEach(dataset => {
          dataset.data.shift();
        });
      }
      
      responseTimeChart.data.labels.push(timeLabel);
      
      services.forEach((service, index) => {
        const responseTime = servicesData[service.id]?.responseTime || null;
        responseTimeChart.data.datasets[index].data.push(responseTime);
      });
      
      responseTimeChart.update();
    }

    // Обновление списка сообщений Telegram
    function updateTelegramMessages() {
      const container = document.getElementById('telegramMessages');
      container.innerHTML = '';
      
      telegramMessages.slice(0, 10).forEach(message => {
        const item = document.createElement('div');
        item.className = 'list-group-item';
        
        const timestamp = new Date(message.timestamp).toLocaleString();
        const content = message.content.replace(/\n/g, '<br>');
        
        item.innerHTML = `
          <div class="d-flex w-100 justify-content-between">
            <h6 class="mb-1">${message.type || 'Сообщение'}</h6>
            <small>${timestamp}</small>
          </div>
          <p class="mb-1">${content}</p>
        `;
        
        container.appendChild(item);
      });
      
      if (telegramMessages.length === 0) {
        container.innerHTML = '<div class="list-group-item">Нет сообщений</div>';
      }
    }

    // Обновление лога восстановлений
    function updateRecoveryLog() {
      const container = document.getElementById('recoveryLog');
      container.innerHTML = '';
      
      recoveryEvents.forEach(event => {
        const item = document.createElement('div');
        item.className = 'list-group-item';
        
        const timestamp = new Date(event.timestamp).toLocaleString();
        const downtime = formatDuration(event.downtime);
        
        item.innerHTML = `
          <div class="d-flex w-100 justify-content-between">
            <h6 class="mb-1">${event.service}</h6>
            <small>${timestamp}</small>
          </div>
          <p class="mb-1">Время простоя: ${downtime}</p>
        `;
        
        container.appendChild(item);
      });
      
      if (recoveryEvents.length === 0) {
        container.innerHTML = '<div class="list-group-item">Нет записей о восстановлении</div>';
      }
    }

    // Форматирование продолжительности
    function formatDuration(seconds) {
      if (seconds < 60) {
        return `${seconds} сек`;
      } else if (seconds < 3600) {
        return `${Math.floor(seconds / 60)} мин ${seconds % 60} сек`;
      } else {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        return `${hours} ч ${minutes} мин`;
      }
    }

    // Настройка обработчиков событий
    function setupEventListeners() {
      // Кнопка отправки отчета
      document.getElementById('sendReportBtn').addEventListener('click', () => {
        fetch('/api/send-report', { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            alert(data.message || 'Отчет отправлен');
            fetchTelegramMessages();
          })
          .catch(error => {
            console.error('Ошибка при отправке отчета:', error);
            alert('Ошибка при отправке отчета');
          });
      });
      
      // Кнопка сохранения настроек
      document.getElementById('saveSettingsBtn').addEventListener('click', () => {
        const settings = {
          healthCheckInterval: parseInt(document.getElementById('healthCheckInterval').value),
          alertThreshold: parseInt(document.getElementById('alertThreshold').value),
          refreshRate: parseInt(document.getElementById('refreshRate').value)
        };
        
        fetch('/api/settings', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(settings)
        })
          .then(response => response.json())
          .then(data => {
            alert(data.message || 'Настройки сохранены');
          })
          .catch(error => {
            console.error('Ошибка при сохранении настроек:', error);
            alert('Ошибка при сохранении настроек');
          });
      });
      
      // Кнопка обновления данных
      document.getElementById('refreshDataBtn').addEventListener('click', () => {
        fetchStatusData();
        fetchTelegramMessages();
        fetchRecoveryLog();
      });
      
      // Кнопка очистки лога восстановлений
      document.getElementById('clearRecoveryLogBtn').addEventListener('click', () => {
        fetch('/api/recovery-log/clear', { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            alert(data.message || 'Лог очищен');
            recoveryEvents = [];
            updateRecoveryLog();
          })
          .catch(error => {
            console.error('Ошибка при очистке лога:', error);
            alert('Ошибка при очистке лога');
          });
      });
    }
  </script>
</body>
</html>